Index: core/src/de/tum/cit/ase/maze/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.tum.cit.ase.maze;\n\nimport com.badlogic.gdx.Gdx;\nimport com.badlogic.gdx.Input;\nimport com.badlogic.gdx.audio.Sound;\nimport com.badlogic.gdx.graphics.Texture;\nimport com.badlogic.gdx.graphics.g2d.Animation;\nimport com.badlogic.gdx.graphics.g2d.Batch;\nimport com.badlogic.gdx.graphics.g2d.TextureRegion;\nimport com.badlogic.gdx.maps.tiled.TiledMapTileLayer;\nimport com.badlogic.gdx.math.Vector2;\nimport com.badlogic.gdx.utils.Array;\n\nimport java.awt.*;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Player {\n    private Texture spriteSheet;\n\n    private float playerX;\n    private float playerY;\n\n    private float speed;\n\n    private int playerWidth;\n    private int playerHeight;\n\n    private TiledMapTileLayer collisionLayer;\n\n    private Rectangle collisionBox;\n    private Rectangle hitBox;\n\n    private boolean isInvincible;\n    private float invincibility_timer;\n    private final float INVINCIBILITY_DURATION;\n\n    private Direction facingDirection;\n    private boolean attacking;\n    private float attackStateTime;\n    private Rectangle attackBox;\n\n    private Vector2 knockBackVector;\n    private float knockBackTime;\n    private final float KNOCKBACKDURATION;\n    private boolean beingKnockedBack;\n\n    private int playerLives;\n\n    private boolean hasKey;\n\n    private Map<String, Animation<TextureRegion>> playerAnimations;\n    private Animation<TextureRegion> currentAnimation;\n\n    private float stateTime;\n\n    private Sound attackSound;\n\n    public Player(float playerX, float playerY, TiledMapTileLayer collisionLayer) {\n        this.playerX = playerX;\n        this.playerY = playerY;\n        this.collisionLayer = collisionLayer;\n        this.speed = 80f;\n        this.playerWidth = 16;\n        this.playerHeight = 32;\n        this.playerLives = 3;\n        this.hasKey = false;\n        isInvincible = false;\n        invincibility_timer = 0f;\n        INVINCIBILITY_DURATION = 2f;\n        facingDirection = Direction.DOWN;\n        attacking = false;\n        attackStateTime = 0f;\n        attackBox = new Rectangle((int) playerX, (int) playerY, 0, 0);\n        attackSound = Gdx.audio.newSound(Gdx.files.internal(\"attack.wav\"));\n        knockBackTime = 0f;\n        KNOCKBACKDURATION = 1f;\n        beingKnockedBack = false;\n        this.collisionBox = new Rectangle((int) playerX + 4, (int) playerY + 6, (int) (playerWidth * 0.5), (int) (playerHeight * 0.2));\n        this.hitBox = new Rectangle((int) playerX + 4, (int) playerY + 8, 8, 15);\n        this.stateTime = 0f;\n        this.spriteSheet = new Texture(Gdx.files.internal(\"character.png\"));\n        this.playerAnimations = this.loadAnimations();\n        this.currentAnimation = this.playerAnimations.get(\"down\");\n    }\n\n    public void update(float delta, int mapWidth, int mapHeight, int borderTiles) {\n        attacking = false;\n        attackBox.setLocation((int) playerX, (int) playerY);\n        attackBox.setSize(0, 0);\n\n        // apply knock back effect if beingKnockedBack is true\n        if (beingKnockedBack) {\n            // count down the knock back timer\n            knockBackTime -= delta;\n            // if the timer is up (reaches 0), set beingKnockedBack to false again\n            if (knockBackTime <= 0) {\n                beingKnockedBack = false;\n            } else {\n                float knockBackFactor = knockBackTime / KNOCKBACKDURATION;\n                Vector2 knockBackThisFrame = knockBackVector.cpy().scl(knockBackFactor);\n\n                // check for collision using potential position\n                Vector2 potentialPosition = new Vector2(collisionBox.x, collisionBox.y).add(knockBackThisFrame);\n                if (knockBackThisFrame.x < 0) {\n                    if (!isCellBlocked(potentialPosition.x, potentialPosition.y) && !isCellBlocked(potentialPosition.x, potentialPosition.y + collisionBox.height)) {\n                        playerX += knockBackThisFrame.x;\n                    } else {\n                        beingKnockedBack = false;\n                    }\n                } else if (knockBackThisFrame.x > 0) {\n                    potentialPosition.add(1, 0);\n                    if (!isCellBlocked(potentialPosition.x + collisionBox.width, potentialPosition.y) && !isCellBlocked(potentialPosition.x + collisionBox.width, potentialPosition.y + collisionBox.height)) {\n                        playerX += knockBackThisFrame.x;\n                    } else {\n                        beingKnockedBack = false;\n                    }\n                } else if (knockBackThisFrame.y < 0) {\n                    if (!isCellBlocked(potentialPosition.x, potentialPosition.y) && !isCellBlocked(potentialPosition.x + collisionBox.width, potentialPosition.y)) {\n                        playerY += knockBackThisFrame.y;\n                    } else {\n                        beingKnockedBack = false;\n                    }\n                }\n                else if (knockBackThisFrame.y > 0) {\n                    potentialPosition.add(0, 1);\n                    if (!isCellBlocked(potentialPosition.x, potentialPosition.y + collisionBox.height) && !isCellBlocked(potentialPosition.x + collisionBox.width, potentialPosition.y + collisionBox.height)) {\n                        playerY += knockBackThisFrame.y;\n                    } else {\n                        beingKnockedBack = false;\n                    }\n                }\n            }\n        }\n\n        // check to see if the player is invincible, if invincible, count down the timer\n        if (isInvincible) {\n            invincibility_timer -= delta;\n            if (invincibility_timer <= 0) {\n                isInvincible = false;\n            }\n        }\n\n        // restrict so that the player can't go outside the maze walls\n        if (playerX < borderTiles * 16) playerX = borderTiles * 16;\n        if (playerX > (mapWidth + borderTiles - 1) * 16) playerX = (mapWidth + borderTiles - 1) * 16;\n        if (playerY < borderTiles * 16) playerY = borderTiles * 16;\n        if (playerY > (mapHeight + borderTiles - 1) * 16) playerY = (mapHeight + borderTiles - 1) * 16;\n\n        // move player according to the input\n        if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) {\n            facingDirection = Direction.LEFT;\n            stateTime += delta;\n            currentAnimation = playerAnimations.get(\"left\");\n            float potentialX = collisionBox.x - (speed * delta);\n            if (!isCellBlocked(potentialX, collisionBox.y) && !isCellBlocked(potentialX, collisionBox.y + collisionBox.height)) {\n                playerX -= speed * delta;\n            }\n        } else if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) {\n            facingDirection = Direction.RIGHT;\n            stateTime += delta;\n            currentAnimation = playerAnimations.get(\"right\");\n            float potentialX = collisionBox.x + (speed * delta) + 1;\n            if (!isCellBlocked(potentialX + collisionBox.width, collisionBox.y) && !isCellBlocked(potentialX + collisionBox.width, collisionBox.y + collisionBox.height)) {\n                playerX += speed * delta;\n            }\n        } else if (Gdx.input.isKeyPressed(Input.Keys.UP)) {\n            facingDirection = Direction.UP;\n            stateTime += delta;\n            currentAnimation = playerAnimations.get(\"up\");\n            float potentialY = collisionBox.y + (speed * delta) + 1;\n            if (!isCellBlocked(collisionBox.x, potentialY + collisionBox.height) && !isCellBlocked(collisionBox.x + collisionBox.height, potentialY + collisionBox.height)) {\n                playerY += speed * delta;\n            }\n        } else if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) {\n            facingDirection = Direction.DOWN;\n            stateTime += delta;\n            currentAnimation = playerAnimations.get(\"down\");\n            float potentialY = collisionBox.y - (speed * delta);\n            if (!isCellBlocked(collisionBox.x, potentialY) && !isCellBlocked(collisionBox.x + collisionBox.width, potentialY)) {\n                playerY -= speed * delta;\n            }\n        } else if (Gdx.input.isKeyPressed(Input.Keys.A)) {\n            attacking = true;\n            attackStateTime += delta;\n            if (isSwingingSword()) {\n                updateAttackBox(facingDirection);\n                attackSound.play();\n            }\n        }\n\n        this.collisionBox.setLocation((int) playerX + 4, (int) playerY + 6);\n\n        // update the size and location of player's hit box accordingly\n        this.hitBox.setLocation((int) playerX + 4, (int) playerY + 8);\n        switch (facingDirection) {\n            case UP, DOWN:\n                hitBox.setSize(8, 10);\n                break;\n            case LEFT, RIGHT:\n                hitBox.setSize(8, 15);\n                break;\n        }\n    }\n\n    private boolean isCellBlocked(float x, float y) {\n        TiledMapTileLayer.Cell cell = collisionLayer.getCell((int) (x / 16), (int) (y / 16));\n        return cell != null && cell.getTile() != null && cell.getTile().getId() == 0;\n    }\n\n    public void draw (Batch batch) {\n        if (attacking) {\n            if (facingDirection.equals(Direction.LEFT)) {\n                batch.draw(\n                        playerAnimations.get(\"attack-left\").getKeyFrame(attackStateTime * 1.2f, true),\n                        playerX - 8,\n                        playerY,\n                        32,\n                        32\n                );\n            } else if (facingDirection.equals(Direction.RIGHT)) {\n                batch.draw(\n                        playerAnimations.get(\"attack-right\").getKeyFrame(attackStateTime * 1.2f, true),\n                        playerX - 8,\n                        playerY,\n                        32,\n                        32\n                );\n            } else if (facingDirection.equals(Direction.UP)) {\n                batch.draw(\n                        playerAnimations.get(\"attack-up\").getKeyFrame(attackStateTime * 1.2f, true),\n                        playerX - 8,\n                        playerY,\n                        32,\n                        32\n                );\n            } else if (facingDirection.equals(Direction.DOWN)) {\n                batch.draw(\n                        playerAnimations.get(\"attack-down\").getKeyFrame(attackStateTime * 1.2f, true),\n                        playerX - 8,\n                        playerY,\n                        32,\n                        32\n                );\n            }\n        } else {\n            batch.draw(\n                    currentAnimation.getKeyFrame(stateTime, true),\n                    playerX,\n                    playerY,\n                    playerWidth,\n                    playerHeight\n            );\n        }\n    }\n\n    /**\n     * Updates the location and size of the attackBox based on the player's facing direction.\n     * <p>\n     * This method adjusts the attackBox's position and dimensions to align with the player's\n     * current direction. The attackBox represents the area where the player's attack can hit.\n     * The method takes into account four possible directions: LEFT, RIGHT, UP, and DOWN.\n     * Depending on the direction, the attackBox is repositioned and resized accordingly to\n     * reflect the player's attack range and orientation.\n     * </p>\n     *\n     * @param direction The direction the player is facing. It should be one of the enum values:\n     *                  LEFT, RIGHT, UP, or DOWN. This parameter dictates how the attackBox\n     *                  will be updated in terms of location and size.\n     * @throws NullPointerException if the direction is null.\n     * @see Direction\n     */\n    public void updateAttackBox(Direction direction) {\n        switch (direction){\n            case LEFT:\n                attackBox.setLocation((int) playerX - 6, (int) playerY + 4);\n                attackBox.setSize(7, 16);\n                break;\n            case RIGHT:\n                attackBox.setLocation((int) playerX + 14, (int) playerY + 4);\n                attackBox.setSize(7, 16);\n                break;\n            case UP:\n                attackBox.setLocation((int) playerX, (int) playerY + 18);\n                attackBox.setSize(16, 7);\n                break;\n            case DOWN:\n                attackBox.setLocation((int) playerX, (int) playerY + 1);\n                attackBox.setSize(16, 7);\n                break;\n        }\n    }\n\n    private Map<String, Animation<TextureRegion>> loadAnimations() {\n        Map<String, Animation<TextureRegion>> animationMap = new HashMap<>();\n\n        // define frame width, height and total frame per circle (there are 4 frames in 1 walking circle)\n        int FRAME_WIDTH = 16;\n        int FRAME_HEIGHT = 32;\n        int ANIMATION_FRAMES = 4;\n\n        // LibGDX Array to load each frame needed for the animation\n        Array<TextureRegion> walkFrames = new Array<>(TextureRegion.class);\n\n        // walking down (1st row, 4 columns)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * FRAME_WIDTH, 0, FRAME_WIDTH, FRAME_HEIGHT));\n        }\n        animationMap.put(\"down\", new Animation<>(0.1f, walkFrames));\n        walkFrames.clear();\n\n        // walking up (3rd row, 4 columns)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * FRAME_WIDTH, 2 * FRAME_HEIGHT, FRAME_WIDTH, FRAME_HEIGHT));\n        }\n        animationMap.put(\"up\", new Animation<>(0.1f, walkFrames));\n        walkFrames.clear();\n\n        // walking left (4th row, 4 columns)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * FRAME_WIDTH, 3 * FRAME_HEIGHT, FRAME_WIDTH, FRAME_HEIGHT));\n        }\n        animationMap.put(\"left\", new Animation<>(0.1f, walkFrames));\n        walkFrames.clear();\n\n        // walking right (2nd row, 4 columns)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * FRAME_WIDTH, FRAME_HEIGHT, FRAME_WIDTH, FRAME_HEIGHT));\n        }\n        animationMap.put(\"right\", new Animation<>(0.1f, walkFrames));\n        walkFrames.clear();\n\n        // attacking face down (32 x 32, 5th row)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * 32, 4 * FRAME_HEIGHT, 32, 32));\n        }\n        animationMap.put(\"attack-down\", new Animation<>(.12f, walkFrames));\n        walkFrames.clear();\n\n        // attacking face up (32 x 32, 6th row)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * 32, 5 * FRAME_HEIGHT, 32, 32));\n        }\n        animationMap.put(\"attack-up\", new Animation<>(.12f, walkFrames));\n        walkFrames.clear();\n\n        // attacking face right (32 x 32, 7th row)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * 32, 6 * FRAME_HEIGHT, 32, 32));\n        }\n        animationMap.put(\"attack-right\", new Animation<>(.12f, walkFrames));\n        walkFrames.clear();\n\n        // attacking face left (32 x 32, 8th row)\n        for (int col = 0; col < ANIMATION_FRAMES; col++) {\n            walkFrames.add(new TextureRegion(spriteSheet, col * 32, 7 * FRAME_HEIGHT, 32, 32));\n        }\n        animationMap.put(\"attack-left\", new Animation<>(.12f, walkFrames));\n        walkFrames.clear();\n\n        return animationMap;\n    }\n\n    /**\n     * Determines if the player is currently swinging his sword during the attack animation cycle.\n     * <p>\n     * This method calculates the current animation frame index based on the attack state time.\n     * It specifically checks if the animation is in the frames where the sword swing occurs,\n     * typically identified by frame index 3. These frames are considered to represent\n     * the sword swinging action in the attack cycle.\n     * </p>\n     *\n     * @return {@code true} if the current animation frame is either 2 or 3, indicating a sword swing;\n     *         {@code false} otherwise.\n     *\n     * @see Player#update(float, int, int, int)\n     */\n    public boolean isSwingingSword() {\n        int frameIndex = (int) ((attackStateTime % (.12f * 4)) / .12f);\n        if (frameIndex == 3) {\n            return true;\n        }\n        return false;\n    }\n\n    public void takeDamage() {\n        if (!isInvincible) {\n            playerLives--;\n            isInvincible = true;\n            invincibility_timer = INVINCIBILITY_DURATION;\n        }\n    }\n\n    /**\n     * Applies a knockback effect to the player based on the position of the colliding mob.\n     * <p>\n     * This method sets the player into a knockedback state, where the player is momentarily pushed\n     * away from the mob they have collided with. The direction and distance of the knockback are\n     * determined by the player's current facing direction and the position of the mob. The\n     * {@code knockBackVector} is calculated to represent this direction and is scaled by the\n     * specified knockback distance. The method also initializes {@code knockBackTime} to\n     * {@code KNOCKBACKDURATION}, starting the timer for the knockback animation, and sets\n     * {@code beingKnockedBack} to true, indicating the player is in the knockback state.\n     * </p>\n     *\n     * @param mob The mob with which the player has collided. This is used to calculate the\n     *            direction of the knockback.\n     * @param knockBackDistance The distance the player should be knocked back. This value\n     *                          scales the {@code knockBackVector}.\n     * @throws NullPointerException if {@code mob} is null.\n     *\n     * @see Mob\n     */\n    public void applyKnockBack(Mob mob, float knockBackDistance) {\n        switch (facingDirection) {\n            case UP, DOWN:\n                knockBackVector = new Vector2(0, playerY - mob.getY());\n                break;\n            case LEFT, RIGHT:\n                knockBackVector = new Vector2(playerX - mob.getX(), 0);\n                break;\n        }\n\n        knockBackVector.nor();\n        knockBackVector.scl(knockBackDistance);\n\n        knockBackTime = KNOCKBACKDURATION;\n        beingKnockedBack = true;\n    }\n\n    public Texture getSpriteSheet() {\n        return spriteSheet;\n    }\n\n    public void setSpriteSheet(Texture spriteSheet) {\n        this.spriteSheet = spriteSheet;\n    }\n\n    public float getPlayerX() {\n        return playerX;\n    }\n\n    public void setPlayerX(float playerX) {\n        this.playerX = playerX;\n    }\n\n    public float getPlayerY() {\n        return playerY;\n    }\n\n    public void setPlayerY(float playerY) {\n        this.playerY = playerY;\n    }\n\n    public float getSpeed() {\n        return speed;\n    }\n\n    public void setSpeed(float speed) {\n        this.speed = speed;\n    }\n\n    public int getPlayerWidth() {\n        return playerWidth;\n    }\n\n    public void setPlayerWidth(int playerWidth) {\n        this.playerWidth = playerWidth;\n    }\n\n    public int getPlayerHeight() {\n        return playerHeight;\n    }\n\n    public void setPlayerHeight(int playerHeight) {\n        this.playerHeight = playerHeight;\n    }\n\n    public Map<String, Animation<TextureRegion>> getPlayerAnimations() {\n        return playerAnimations;\n    }\n\n    public void setPlayerAnimations(Map<String, Animation<TextureRegion>> playerAnimations) {\n        this.playerAnimations = playerAnimations;\n    }\n\n    public Animation<TextureRegion> getCurrentAnimation() {\n        return currentAnimation;\n    }\n\n    public void setCurrentAnimation(Animation<TextureRegion> currentAnimation) {\n        this.currentAnimation = currentAnimation;\n    }\n\n    public float getStateTime() {\n        return stateTime;\n    }\n\n    public void setStateTime(float stateTime) {\n        this.stateTime = stateTime;\n    }\n\n    public TiledMapTileLayer getCollisionLayer() {\n        return collisionLayer;\n    }\n\n    public void setCollisionLayer(TiledMapTileLayer collisionLayer) {\n        this.collisionLayer = collisionLayer;\n    }\n\n    public Rectangle getCollisionBox() {\n        return collisionBox;\n    }\n\n    public void setCollisionBox(Rectangle collisionBox) {\n        this.collisionBox = collisionBox;\n    }\n\n    public Rectangle getHitBox() {\n        return hitBox;\n    }\n\n    public void setHitBox(Rectangle hitBox) {\n        this.hitBox = hitBox;\n    }\n\n    public int getPlayerLives() {\n        return playerLives;\n    }\n\n    public void setPlayerLives(int playerLives) {\n        this.playerLives = playerLives;\n    }\n\n    public boolean isInvincible() {\n        return isInvincible;\n    }\n\n    public void setInvincible(boolean invincible) {\n        isInvincible = invincible;\n    }\n\n    public float getInvincibility_timer() {\n        return invincibility_timer;\n    }\n\n    public void setInvincibility_timer(float invincibility_timer) {\n        this.invincibility_timer = invincibility_timer;\n    }\n\n    public float getINVINCIBILITY_DURATION() {\n        return INVINCIBILITY_DURATION;\n    }\n\n    public Vector2 getKnockBackVector() {\n        return knockBackVector;\n    }\n\n    public void setKnockBackVector(Vector2 knockBackVector) {\n        this.knockBackVector = knockBackVector;\n    }\n\n    public float getKnockBackTime() {\n        return knockBackTime;\n    }\n\n    public void setKnockBackTime(float knockBackTime) {\n        this.knockBackTime = knockBackTime;\n    }\n\n    public float getKNOCKBACKDURATION() {\n        return KNOCKBACKDURATION;\n    }\n\n    public boolean isBeingKnockedBack() {\n        return beingKnockedBack;\n    }\n\n    public void setBeingKnockedBack(boolean beingKnockedBack) {\n        this.beingKnockedBack = beingKnockedBack;\n    }\n\n    public boolean isHasKey() {\n        return hasKey;\n    }\n\n    public void setHasKey(boolean hasKey) {\n        this.hasKey = hasKey;\n    }\n\n    public Direction getFacingDirection() {\n        return facingDirection;\n    }\n\n    public void setFacingDirection(Direction facingDirection) {\n        this.facingDirection = facingDirection;\n    }\n\n    public boolean isAttacking() {\n        return attacking;\n    }\n\n    public void setAttacking(boolean attacking) {\n        this.attacking = attacking;\n    }\n\n    public float getAttackStateTime() {\n        return attackStateTime;\n    }\n\n    public void setAttackStateTime(float attackStateTime) {\n        this.attackStateTime = attackStateTime;\n    }\n\n    public Rectangle getAttackBox() {\n        return attackBox;\n    }\n\n    public void setAttackBox(Rectangle attackBox) {\n        this.attackBox = attackBox;\n    }\n\n    public void dispose() {\n        spriteSheet.dispose();\n        attackSound.dispose();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/de/tum/cit/ase/maze/Player.java b/core/src/de/tum/cit/ase/maze/Player.java
--- a/core/src/de/tum/cit/ase/maze/Player.java	(revision 48883c6522b35e08a62819ebd2e986d1ad438d5f)
+++ b/core/src/de/tum/cit/ase/maze/Player.java	(date 1706091958553)
@@ -72,7 +72,7 @@
         attacking = false;
         attackStateTime = 0f;
         attackBox = new Rectangle((int) playerX, (int) playerY, 0, 0);
-        attackSound = Gdx.audio.newSound(Gdx.files.internal("attack.wav"));
+        attackSound = Gdx.audio.newSound(Gdx.files.internal("swing.wav"));
         knockBackTime = 0f;
         KNOCKBACKDURATION = 1f;
         beingKnockedBack = false;
